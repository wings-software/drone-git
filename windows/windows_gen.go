package windows

// DO NOT EDIT. This file is automatically generated.

// Contents of windows/clone.ps1
const Windows/Clone = `$ErrorActionPreference = 'Stop';

# HACK: no clue how to set the PATH inside the Dockerfile,
# so am setting it here instead. This is not idea.
$Env:PATH += ';C:\git\cmd;C:\git\mingw64\bin;C:\git\usr\bin;C:\openssh'

# if the workspace is set we should create it and make sure it is the current working directory.
if ($Env:DRONE_WORKSPACE) {
    md -Force $Env:DRONE_WORKSPACE
    cd $Env:DRONE_WORKSPACE
}

# if the netrc enviornment variables exist, write
# the netrc file.

if ($Env:DRONE_NETRC_MACHINE) {
@"
machine $Env:DRONE_NETRC_MACHINE
login $Env:DRONE_NETRC_USERNAME
password $Env:DRONE_NETRC_PASSWORD
"@ > (Join-Path $Env:USERPROFILE '_netrc');
}

# Windows-specific: Persist Git credentials by mounting _netrc from the shared path
# so that subsequent steps in the pipeline can use them for authenticated Git operations.
if ($Env:DRONE_PERSIST_CREDS) {
        $sourcePath = Join-Path $Env:USERPROFILE '_netrc';
    $destinationPath = 'C:\addon\shared\_netrc';
    New-Item -ItemType Directory -Path (Split-Path $destinationPath) -Force;
    if (Test-Path -Path $sourcePath) {
        Copy-Item -Path $sourcePath -Destination $destinationPath -Force;
    }
}

if ($Env:DRONE_SSH_KEY) {
    # Create .ssh directory in user profile (Windows standard location)
    $sshDir = Join-Path $Env:USERPROFILE '.ssh'
    New-Item -ItemType Directory -Path $sshDir -Force | Out-Null
    
    # Write SSH key with proper line endings
    $keyPath = Join-Path $sshDir 'id_rsa'
    $Env:DRONE_SSH_KEY | Out-File -FilePath $keyPath -Encoding ascii -NoNewline
    
    # Set proper permissions for SSH key (Windows equivalent of chmod 600)
    $acl = Get-Acl $keyPath
    $acl.SetAccessRuleProtection($true, $false)  # Remove inheritance
    $accessRule = New-Object System.Security.AccessControl.FileSystemAccessRule(
        [System.Security.Principal.WindowsIdentity]::GetCurrent().Name,
        'FullControl',
        'Allow'
    )
    $acl.SetAccessRule($accessRule)
    Set-Acl -Path $keyPath -AclObject $acl
    
    # Set GIT_SSH_COMMAND with proper Windows path format
    $Env:GIT_SSH_COMMAND="ssh -i `"$keyPath`" -o StrictHostKeyChecking=no -o UserKnownHostsFile=NUL"
}

# configure git global behavior and parameters via the
# following environment variables:

if ($Env:PLUGIN_SKIP_VERIFY) {
    $Env:GIT_SSL_NO_VERIFY = "true"
}

if ($Env:DRONE_COMMIT_AUTHOR_NAME -eq '' -or $Env:DRONE_COMMIT_AUTHOR_NAME -eq $null) {
    $Env:GIT_AUTHOR_NAME = "drone"
} else {
    $Env:GIT_AUTHOR_NAME = $Env:DRONE_COMMIT_AUTHOR_NAME
}

if ($Env:DRONE_COMMIT_AUTHOR_EMAIL -eq '' -or $Env:DRONE_COMMIT_AUTHOR_EMAIL -eq $null) {
    $Env:GIT_AUTHOR_EMAIL = 'drone@localhost'
} else {
    $Env:GIT_AUTHOR_EMAIL = $Env:DRONE_COMMIT_AUTHOR_EMAIL
}

$Env:GIT_COMMITTER_NAME  = $Env:GIT_AUTHOR_NAME
$Env:GIT_COMMITTER_EMAIL = $Env:GIT_AUTHOR_EMAIL

# invoke the sub-script based on the drone event type.
# TODO we should ultimately look at the ref, since
# we need something compatible with deployment events.

Set-Variable -Name "CLONE_TYPE" -Value "$Env:DRONE_BUILD_EVENT"
switch -regex ($Env:DRONE_COMMIT_REF)
{
    'refs/tags/*' {
        Set-Variable -Name "CLONE_TYPE" -Value "tag"
        break
    }

    'refs/pull/*' {
        Set-Variable -Name "CLONE_TYPE" -Value "pull_request"
        break
    }

    'refs/pull-request/*' {
        Set-Variable -Name "CLONE_TYPE" -Value "pull_request"
        break
    }

    'refs/merge-requests/*' {
        Set-Variable -Name "CLONE_TYPE" -Value "pull_request"
        break
    }

}

Invoke-Expression "${PSScriptRoot}\common.ps1"

switch ($CLONE_TYPE) {
    "pull_request" {
        Invoke-Expression "${PSScriptRoot}\clone-pull-request.ps1"
        break
    }
    "tag" {
        Invoke-Expression "${PSScriptRoot}\clone-tag.ps1"
        break
    }
    default {
        Invoke-Expression "${PSScriptRoot}\clone-commit.ps1"
        break
    }
}

Invoke-Expression "${PSScriptRoot}\post-fetch.ps1"`

// Contents of windows/clone-commit.ps1
const Windows/CloneCommit = `. "${PSScriptRoot}\utility.ps1"
. "${PSScriptRoot}\git-utility.ps1"

Set-Alias iu Invoke-Utility
Set-Alias sf Start-Fetch

Set-Variable -Name "FLAGS" -Value ""
if ($Env:PLUGIN_DEPTH) {
	Set-Variable -Name "FLAGS" -Value "--depth=$Env:PLUGIN_DEPTH" 
}

# the branch may be empty for certain event types,
# such as github deployment events. If the branch
# is empty we checkout the sha directly. Note that
# we intentially omit depth flags to avoid failed
# clones due to lack of history.
if ([string]::IsNullOrEmpty($env:DRONE_COMMIT_BRANCH)) {
	sf -flags $null -ref $null
	Write-Host "+ git checkout -qf ${Env:DRONE_COMMIT_SHA}";
	iu git checkout -qf ${Env:DRONE_COMMIT_SHA}
	exit 0
}

# the commit sha may be empty for builds that are
# manually triggered in Harness CI Enterprise. If
# the commit is empty we clone the branch.
if ([string]::IsNullOrEmpty($env:DRONE_COMMIT_SHA)) {
	sf -flags ${FLAGS} -ref "+refs/heads/${Env:DRONE_COMMIT_BRANCH}"
	Write-Host "+ git checkout -b ${Env:DRONE_COMMIT_BRANCH} origin/${Env:DRONE_COMMIT_BRANCH}";
	iu git checkout -b ${Env:DRONE_COMMIT_BRANCH} origin/${Env:DRONE_COMMIT_BRANCH}
}else{
	sf -flags ${FLAGS} -ref "+refs/heads/${Env:DRONE_COMMIT_BRANCH}"
	Write-Host "+ git checkout ${Env:DRONE_COMMIT_SHA} -b ${Env:DRONE_COMMIT_BRANCH}"
	iu git checkout ${Env:DRONE_COMMIT_SHA} -b ${Env:DRONE_COMMIT_BRANCH}
}`

// Contents of windows/clone-pull-request.ps1
const Windows/ClonePullRequest = `. "${PSScriptRoot}\utility.ps1"
. "${PSScriptRoot}\git-utility.ps1"

Set-Alias iu Invoke-Utility
Set-Alias sf Start-Fetch

Set-Variable -Name "FLAGS" -Value ""
if ($Env:PLUGIN_DEPTH) {
	Set-Variable -Name "FLAGS" -Value "--depth=$Env:PLUGIN_DEPTH"
}

if ($Env:PLUGIN_PR_CLONE_STRATEGY -eq "SourceBranch") {
	sf -flags ${FLAGS} -ref "${Env:DRONE_COMMIT_REF}"
	Write-Host "+ git checkout ${Env:DRONE_COMMIT_SHA} -b ${Env:DRONE_SOURCE_BRANCH}"
	iu git checkout ${Env:DRONE_COMMIT_SHA} -b ${Env:DRONE_SOURCE_BRANCH}
	exit 0
}

sf -flags ${FLAGS} -ref "+refs/heads/${Env:DRONE_COMMIT_BRANCH}"

if (Test-Path env:DRONE_COMMIT_BEFORE) {
	if ($env:DRONE_PR_MERGE_STRATEGY_BRANCH -eq "true") {
		Write-Host "+ git checkout $Env:DRONE_COMMIT_BRANCH"
		iu git checkout $Env:DRONE_COMMIT_BRANCH
	} else {
		# PR clone strategy is merge commit
		Write-Host "+ git checkout ${Env:DRONE_COMMIT_BEFORE} -b ${Env:DRONE_COMMIT_BRANCH}"
		iu git checkout ${Env:DRONE_COMMIT_BEFORE} -b ${Env:DRONE_COMMIT_BRANCH}
	}
} else {
	Write-Host "+ git checkout $Env:DRONE_COMMIT_BRANCH"
	iu git checkout $Env:DRONE_COMMIT_BRANCH
}

sf -flags $null -ref "${Env:DRONE_COMMIT_REF}"

Write-Host "+ git merge $Env:DRONE_COMMIT_SHA"
iu git merge $Env:DRONE_COMMIT_SHA`

// Contents of windows/clone-tag.ps1
const Windows/CloneTag = `. "${PSScriptRoot}\utility.ps1"
. "${PSScriptRoot}\git-utility.ps1"

Set-Alias iu Invoke-Utility
Set-Alias sf Start-Fetch

Set-Variable -Name "FLAGS" -Value ""
if ($Env:PLUGIN_DEPTH) {
    Set-Variable -Name "FLAGS" -Value "--depth=$Env:PLUGIN_DEPTH" 
}

sf -flags ${FLAGS} -ref "+refs/tags/${Env:DRONE_TAG}"
Write-Host "+ git checkout -qf ${Env:FETCH_HEAD}";
iu git checkout -qf FETCH_HEAD
`

